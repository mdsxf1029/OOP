# C++面向对象编程（学长笔记基础之上）【杂碎知识点版】

!!! note "C++四大内存分区"
    - 程序运行前：
      - 代码区：存放程序执行的代码。
      - 全局区：存放全局变量、静态变量和常量。
    - 程序运行后：
      - 栈区:存放局部变量和函数参数，生命周期受函数调用控制。
      - 堆区:存放程序通过 `new` 或类似操作动态分配的内存。

!!! note "new操作符"
    - 语法：指针数据类型 指针 = new 数据类型;
    - 因为new的作用是动态分配内存空间，所以返回的是地址
    ```cpp
    int* a = new int(10);  // 将值初始化为10
    delete a;

    int* arr = new int[10];  // 在堆区为这些元素分配连续的内存空间
    delete[] arr;
    ```

!!! note "引用"
    - 作用：给变量起别名（本质上是一个指针常量）
    - 语法：数据类型 &别名 = 原名
    - 注意：
      - 引用必须初始化
      - 引用在初始化后不可以改变，它只会始终引用初始化赋予的变量
      - 函数传参的时候可以用引用代替指针，且语法更清楚简单
      - 引用可以作为函数返回值，但不要返回局部变量的引用，可以返回全局变量、静态变量或通过动态内存分配（如 new）创建的对象的引用
      - 引用作为左值可以像普通变量一样被赋值。

!!! note "函数提高"
    - 函数默认参数：
      - 语法：返回值类型 函数名(参数类型 参数名 = 默认值, ...);
      - 默认参数规则:
        - （从左到右的规则）如果一个参数有默认值，那么从这个参数开始，右侧所有的参数都必须有默认值。
        - （函数声明和定义中的默认值）如果在函数`声明`中给出了默认值，那么在函数`定义`中不能再给出默认值，否则会导致编译错误。
        - 传参时按顺序赋值，有默认值的话代替默认值，没传入的话使用默认值
    - 函数占位参数：
      - 语法：返回值类型 函数名 (数据类型){}
        ```cpp
        //函数占位参数 ，占位参数也可以有默认参数
        void func(int a, int) 
        {
	        cout << "this is func" << endl;
        }    

        int main() 
        {
    	    func(10,10); //占位参数必须填补
            system("pause");
            return 0;
        }
        ```
    - 函数重载：
      - 条件：
        - 同一个作用域下（所有重载函数必须在同一个上下文中定义）
        - 函数名称相同
        - 函数参数 `类型不同` 或者 `个数不同` 或者 `顺序不同`
        - 返回值不可以作为函数重载的条件
        - 引用作为重载条件（`int&` `const int&` 可以重载）
        - 如果函数有默认参数，可能会导致重载冲突，需要避免

!!! note "C++面向对象"
    - 类是 `对象` 的模板，类里面包含的是 `成员`
    - 三大特性：
      - 封装
      - 继承
      - 多态

!!! note "封装"
    - `封装` 指的是将数据（属性）和操作数据的方法（行为）包装在一起，形成一个独立的模块（即类）。这样可以避免直接访问或修改数据，从而提升程序的安全性和可维护性。
    - 意义：
      - 在设计类时，把属性和行为写在一起，表现生活中的事物。
      - 类在设计时，可以把属性和行为放在不同的权限下，加以控制，避免外部随意修改内部数据。
        - public     公共权限  类内可，类外可
        - protected  保护权限  类内可，类外不可（适用于需要允许继承类访问的情况）
        - private    私有权限  类内可，类外不可
      ```cpp
      // 语法：class 类名{ 访问权限： 属性 / 行为 };
        class Circle
        {    
        public:  //访问权限  公共的权限
	        //属性
	        int m_r;//半径
	        //行为
	        //获取到圆的周长
	        double calculateZC()
	        {
	        	return  2 * PI * m_r;
	        }
        };

        int main() 
        {
	        // 通过圆类，创建圆的对象
	        // c1就是一个具体的圆
	        Circle c1;
	        c1.m_r = 10; // 给圆对象的半径 进行赋值操作

	        system("pause");
	        return 0;
        }
      ```
    - `struct` vs `class` 
      - 唯一区别：默认的访问权限不同
        - struct 默认权限为公共
        - class 默认权限为私有
    - 构造函数与析构函数：
      - C++编译器默认提供三个函数：
        - 默认构造函数(无参，函数体为空)
        - 默认析构函数(无参，函数体为空)
        - 默认拷贝构造函数，对属性进行值拷贝
      - 构造函数：
        - 作用：在于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用。
        - 语法：类名(){}
        - 用法：
          - 没有返回值（即使是 void 也不写）
          - 支持重载，可以有参数
          - 只调用一次
        ```cpp
        // 构造函数分类:
        // 按照参数分类分为：1.有参和无参构造；2.无参又为默认构造函数
        // 按照类型分类分为：普通构造和拷贝构造
        class Person {
        public:
	        // 无参（默认）构造函数
	        Person() {
		        cout << "无参构造函数!" << endl;
	        }
	        // 有参构造函数
	        Person(int a) {
	        	age = a;
	        	cout << "有参构造函数!" << endl;
	        }
	        // 拷贝构造函数
	        Person(const Person& p) {
	        	age = p.age;
	        	cout << "拷贝构造函数!" << endl;
	        }
	        // 析构函数
	        ~Person() {
	        	cout << "析构函数!" << endl;
	        }
        public:
	        int age;
        };

        // 构造函数的调用：

        // 1.调用无参构造函数
        void test01() 
        {
	        Person p; //调用无参构造函数
        }
        // 2.调用有参的构造函数
        void test02() 
        {
	        // 1.括号法（常用）
            // ps.调用无参构造函数不能加括号，如果加了编译器认为这是一个函数声明 Person p2();
	        Person p1(10);

	        // 2.显式法
            // ps.Person(10)单独写就是匿名对象，当前行结束之后，马上析构
	        Person p2 = Person(10);  // 使用显式法，等效于 Person p2(10);
	        Person p3 = Person(p2);  // 使用拷贝构造函数创建 p3

	        // 3.隐式转换法
            // ps.不能利用拷贝构造函数初始化匿名对象，编译器认为是对象声明 Person p5(p4);
	        Person p4 = 10; // 隐式调用构造函数，等效于 Person p4 = Person(10); 
	        Person p5 = p4; // 使用拷贝构造函数初始化 p5
        } 
        ```
      - 拷贝构造函数：
        - 理解：
          核心是通过复制另一个对象来初始化当前对象，类比于一般的函数调用
        - 用法：
        ```cpp
        // 拷贝构造函数的调用；
        
        // 1.使用一个已经创建完毕的对象来初始化一个新对象
        // 2.值传递的方式给函数参数传值
        // 3.以值方式返回局部对象（同上）
        void func(Person p)  // p 是值传递，调用拷贝构造函数
        { 
            cout << "Person's ID: " << p.getID() << endl;
        }
        int main() 
        {
            Person p1(10);  // 创建 p1
            func(p1);       // 调用拷贝构造函数将 p1 传递给函数 func
        }
        // 在 func(p1) 这一行，编译器会调用拷贝构造函数，将 p1 的值拷贝到 func 函数中的 p 参数上。这意味着函数 func 内部的 p 对象是 p1 的一个副本。
        ```
        - 深拷贝与浅拷贝：
          - 浅拷贝：
            - 简单的赋值拷贝操作
          - 深拷贝：
            - 当对象中包含指向堆内存（如指针）的成员时，拷贝构造函数需要重新分配空间，以确保新对象与原对象的指针成员指向不同的内存区域，从而避免共享同一块内存（即避免浅拷贝可能导致的问题）
      - 析构函数：
        - 作用：在于对象销毁前系统自动调用，执行一些清理工作。
        - 语法：~类名(){}
        - 用法：
          - 没有返回值
          - 不能重载，不支持参数
          - 只调用一次
    - 初始化列表：
      - 语法：构造函数()：属性1(值1),属性2（值2）... {}
        ```cpp
        class Person 
        {
        public:
	        // 传统方式初始化
	        Person(int a, int b, int c) 
            {
	            m_A = a;
	            m_B = b;
	            m_C = c;
	        }
	        //初始化列表方式初始化
	        Person(int a, int b, int c) :m_A(a), m_B(b), m_C(c) {}
	    }
        private:
	        int m_A, m_B, m_C;
        };
        ```
    - 类成员：
      - 对象成员：指类中成员的类型是另一个类的对象
        ```cpp
        class A {}
        class B
        {
            A a；
        }
        ```
        - 构造的顺序是：先调用对象成员的构造，再调用本类构造
        - 析构顺序与构造相反
      - 静态成员：static+成员变量/成员函数
        - 在编译阶段分配内存，生命周期独立于对象
        - 类内声明，类外初始化
        - 静态成员函数只能访问静态成员变量
        - 所有对象共享同一份数据，全类共享一份内存/程序共享一个函数
        ```cpp
	    // 静态成员变量两种访问方式：

	    // 1.通过对象
	    Person p1;
	    p1.m_A = 100;
	    cout << "p1.m_A = " << p1.m_A << endl;

	    Person p2;
	    p2.m_A = 200;
	    cout << "p1.m_A = " << p1.m_A << endl;  // 共享同一份数据，两个都输出200
	    cout << "p2.m_A = " << p2.m_A << endl;

	    // 2.通过类名
	    cout << "m_A = " << Person::m_A << endl;
        ```
        ```cpp
        // 静态成员函数两种访问方式：
	    class Person
        {
        public:
	        static void func() {}
        };
        void test01()
        {
	        // 静态成员变量两种访问方式：

	        // 1.通过对象
	        Person p1;
	        p1.func();

	        // 2.通过类名
	        Person::func();
        }
        ```
    - C++对象模型和this指针
      - 成员变量和成员函数的存储分离：
        - 非静态成员变量占对象空间
        - 静态成员变量不占对象空间
        - 函数也不占对象空间，所有函数共享一个函数实例
      - this指针：
        - 每个非静态成员函数都有一个隐含的指针 `this`，指向调用该成员函数的对象
        ```cpp
        class Person
        {
        public:
	        Person(int age)
	        {
		        // 当形参和成员变量同名时，可用this指针来区分
		        this->age = age;
	        }
	        Person& Add(Person p)
	        {
		        this->age += p.age;
		        //返回对象本身
		        return *this;
	        }
	        int age;
        };

        void test01()
        {
	        Person p1(10);
	        cout << "p1.age = " << p1.age << endl;
            
            // 链式调用：是指在一条语句中连续调用多个成员函数
            // 每个成员函数返回对象自身的引用，允许下一个函数调用在同一个对象上进行
	        Person p2(10);
	        p2.Add(p1).Add(p1).Add(p1);  
	        cout << "p2.age = " << p2.age << endl;  // 输出为40
        }
        ```
      - 空指针：
        - 空指针可以调用成员函数，但成员函数中不能有对类成员的访问
    - const修饰成员函数：

!!! note "继承"

!!! note "多态"